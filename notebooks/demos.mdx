import GradioLiteDemo from "../../../components/GradioLiteDemo.jsx"

# Demos

## Optimization
### BASINHOPPING

<GradioLiteDemo files={ [
  {
    "name": "gradio_basinhopping.py",
    "content": "# Gradio demo for basinhopping\nimport gradio as gr\nimport json\nimport os\nfrom basinhopping import basinhopping\n\ndef run_basinhopping(func_expr, x_zero, niter, T, stepsize, minimizer_method):\n    # Parse x_zero: require scalar or 2D list (e.g. [[0, 0]])\n    try:\n        if isinstance(x_zero, (int, float)):\n            x0_val = x_zero\n        elif isinstance(x_zero, str):\n            x0_val = json.loads(x_zero)\n        else:\n            x0_val = x_zero\n        # Enforce 2D list for multivariate\n        if isinstance(x0_val, list):\n            if len(x0_val) > 0 and not isinstance(x0_val[0], list):\n                x0_val = [x0_val]\n    except Exception:\n        return \"x_zero must be a scalar or a 2D list (e.g. [[0, 0]])\"\n    try:\n        niter = int(niter)\n    except Exception:\n        niter = 100\n    try:\n        T = float(T)\n    except Exception:\n        T = 1.0\n    try:\n        stepsize = float(stepsize)\n    except Exception:\n        stepsize = 0.5\n    if not minimizer_method:\n        minimizer_method = 'L-BFGS-B'\n    result = basinhopping(func_expr, x0_val, niter=niter, T=T, stepsize=stepsize, minimizer_method=minimizer_method)\n    if isinstance(result, list):\n        # Format as table string\n        header = [\"Minimum\"] + [f\"x{i}\" for i in range(1, len(result[0]))]\n        rows = [header] + [[str(v) for v in row] for row in result]\n        return \"\\n\".join([\"\\t\".join(row) for row in rows])\n    return str(result)\n\ndef load_demo_examples():\n    test_cases_path = os.path.join(os.path.dirname(__file__), \"test_cases.json\")\n    with open(test_cases_path, \"r\", encoding=\"utf-8\") as f:\n        cases = json.load(f)\n    examples = []\n    for case in cases:\n        if case.get(\"demo\"):\n            args = case[\"arguments\"]\n            func_expr = args.get(\"func_expr\", \"\")\n            x_zero = args.get(\"x0\", \"\")\n            niter = args.get(\"niter\", 100)\n            T = args.get(\"T\", 1.0)\n            stepsize = args.get(\"stepsize\", 0.5)\n            minimizer_method = args.get(\"minimizer_method\", \"L-BFGS-B\")\n            # Format x0 as string for textbox\n            if isinstance(x_zero, list):\n                x0_str = json.dumps(x_zero)\n            else:\n                x0_str = str(x_zero)\n            examples.append([\n                func_expr,\n                x0_str,\n                niter,\n                T,\n                stepsize,\n                minimizer_method\n            ])\n    return examples\n\nexamples = load_demo_examples()\n\nwith gr.Blocks() as demo:\n    gr.Markdown(\"\"\"\n    # Basinhopping Global Optimization Demo\n    Enter a Python lambda function (as a string), initial guess (scalar or 2D list, e.g. [[0, 0]]), and optional parameters. See demo examples below for typical usage. Results are shown as a table: minimum value and coordinates.\n    \"\"\")\n    with gr.Row():\n        func_expr = gr.Textbox(label=\"Function Expression (e.g. lambda x: x**2 + 10*math.sin(x))\", lines=2)\n    with gr.Row():\n        x_zero = gr.Textbox(label=\"Initial Guess x_zero (scalar or [[x0, x1, ...]])\", value=\"0\")\n    with gr.Row():\n        niter = gr.Number(label=\"Number of Iterations (niter)\", value=100)\n        T = gr.Number(label=\"Temperature (T)\", value=1.0)\n        stepsize = gr.Number(label=\"Step Size\", value=0.5)\n        minimizer_method = gr.Textbox(label=\"Minimizer Method\", value=\"L-BFGS-B\")\n    output = gr.Textbox(label=\"Result Table or Error Message\", lines=4)\n    submit = gr.Button(\"Run\")\n    submit.click(run_basinhopping, inputs=[func_expr, x_zero, niter, T, stepsize, minimizer_method], outputs=output)\n    gr.Examples(\n        examples=examples,\n        inputs=[func_expr, x_zero, niter, T, stepsize, minimizer_method],\n        outputs=output,\n        label=\"Demo Examples\"\n    )\n\ndemo.launch()\n",
    "entrypoint": true
  },
  {
    "name": "basinhopping.py",
    "content": "import numpy as np\nfrom scipy.optimize import basinhopping as scipy_basinhopping\nimport math\n\ndef basinhopping(func_expr, x_zero, niter=100, T=1.0, stepsize=0.5, minimizer_method='L-BFGS-B'):\n    \"\"\"\n    Finds the global minimum of a function using the basinhopping algorithm.\n\n    Args:\n        func_expr (str): Python lambda expression as a string, e.g., \"lambda x: x**2 + 10*math.sin(x)\"\n        x_zero (scalar or 2D list): Initial guess. Must be a scalar or a 2D list (e.g., [[0, 0]] for 2 variables)\n        niter (int, optional): Number of basinhopping iterations\n        T (float, optional): Temperature parameter\n        stepsize (float, optional): Step size for random displacement\n        minimizer_method (str, optional): Local minimization method\n\n    Returns:\n        2D list: [[minimum, x_min[0], x_min[1], ...]] or error message as string\n    \"\"\"\n    try:\n        # Validate and parse func_expr\n        if not isinstance(func_expr, str):\n            return \"func_expr must be a string representing a lambda expression.\"\n        try:\n            user_func = eval(func_expr, {\"np\": np, \"math\": math, \"sin\": math.sin, \"cos\": math.cos, \"exp\": math.exp, \"sqrt\": math.sqrt})\n        except Exception as e:\n            return f\"Invalid function expression: {str(e)}\"\n        # Wrap user_func to always return a scalar float\n        def func(x):\n            try:\n                val = user_func(x)\n                if isinstance(val, np.ndarray):\n                    return float(val.item())\n                return float(val)\n            except Exception as e:\n                return float('inf')  # Penalize errors in user function\n        # Validate x_zero\n        if isinstance(x_zero, (int, float)):\n            x0_val = float(x_zero)\n        elif isinstance(x_zero, (list, tuple, np.ndarray)):\n            # Accept only 2D lists for x_zero\n            arr = np.array(x_zero, dtype=float)\n            if arr.ndim == 2 and arr.shape[0] == 1:\n                x0_val = arr[0]\n            else:\n                return \"x_zero must be a scalar or a 2D list with shape (1, n).\"\n        else:\n            return \"x_zero must be a scalar or a 2D list.\"\n        # Validate niter\n        if not isinstance(niter, int) or niter <= 0:\n            return \"niter must be a positive integer.\"\n        # Validate T\n        if not isinstance(T, (int, float)) or T <= 0:\n            return \"T must be a positive number.\"\n        if not isinstance(stepsize, (int, float)) or stepsize <= 0:\n            return \"stepsize must be a positive number.\"\n        # Validate minimizer_method\n        if not isinstance(minimizer_method, str):\n            return \"minimizer_method must be a string.\"\n        # Run basinhopping\n        result = scipy_basinhopping(func, x0_val, niter=niter, T=T, stepsize=stepsize, minimizer_kwargs={\"method\": minimizer_method})\n        x_min = result.x\n        min_val = result.fun\n        # Fix for numpy deprecation: ensure min_val is a scalar, not an array\n        if isinstance(min_val, np.ndarray):\n            min_val = float(min_val.item())\n        else:\n            min_val = float(min_val)\n        # Format output for Excel: [[min, x0, x1, ...]]\n        if isinstance(x_min, np.ndarray):\n            x_min_list = x_min.tolist()\n        else:\n            x_min_list = [float(x_min)]\n        return [[min_val] + x_min_list]\n    except Exception as e:\n        return str(e)\n"
  },
  {
    "name": "test_cases.json",
    "content": "[\n    {\n        \"id\": \"test_quadratic\",\n        \"description\": \"Minimize a simple quadratic function.\",\n        \"arguments\": {\n            \"func_expr\": \"lambda x: (x-3)**2 + 2\",\n            \"x_zero\": 0\n        },\n        \"expected_min_range\": [\n            1.99,\n            2.01\n        ],\n        \"expected_x_range\": [\n            [\n                2.99,\n                3.01\n            ]\n        ],\n        \"expected_rows\": 1,\n        \"demo\": true\n    },\n    {\n        \"id\": \"test_multimodal\",\n        \"description\": \"Minimize a multimodal function.\",\n        \"arguments\": {\n            \"func_expr\": \"lambda x: x**2 + 10*math.sin(x)\",\n            \"x_zero\": -2,\n            \"niter\": 300\n        },\n        \"expected_min_range\": [\n            -8.1,\n            -7.3\n        ],\n        \"expected_x_range\": [\n            [\n                -1.7,\n                -1.3\n            ]\n        ],\n        \"expected_rows\": 1,\n        \"demo\": true\n    },\n    {\n        \"id\": \"test_multivariate\",\n        \"description\": \"Minimize a 2D quadratic function.\",\n        \"arguments\": {\n            \"func_expr\": \"lambda x: (x[0]-1)**2 + (x[1]+2)**2\",\n            \"x_zero\": [\n                [\n                    0,\n                    0\n                ]\n            ],\n            \"niter\": 200\n        },\n        \"expected_min_range\": [\n            -0.01,\n            0.01\n        ],\n        \"expected_x_range\": [\n            [\n                0.99,\n                1.01\n            ],\n            [\n                -2.01,\n                -1.99\n            ]\n        ],\n        \"expected_rows\": 1,\n        \"demo\": true\n    },\n    {\n        \"id\": \"test_invalid_func_expr\",\n        \"description\": \"Invalid function expression should return error message.\",\n        \"arguments\": {\n            \"func_expr\": \"not_a_lambda\",\n            \"x_zero\": 0\n        },\n        \"expected_rows\": 1,\n        \"demo\": false\n    },\n    {\n        \"id\": \"test_invalid_x_zero\",\n        \"description\": \"Invalid x_zero type should return error message.\",\n        \"arguments\": {\n            \"func_expr\": \"lambda x: x**2\",\n            \"x_zero\": \"bad\"\n        },\n        \"expected_rows\": 1,\n        \"demo\": false\n    },\n    {\n        \"id\": \"test_invalid_niter\",\n        \"description\": \"Invalid niter should return error message.\",\n        \"arguments\": {\n            \"func_expr\": \"lambda x: x**2\",\n            \"x_zero\": 0,\n            \"niter\": -5\n        },\n        \"expected_rows\": 1,\n        \"demo\": false\n    }\n]"
  }
] } />
### CURVE_FIT

<GradioLiteDemo files={ [
  {
    "name": "gradio_curve_fit.py",
    "content": "import sys\nimport os\nsys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '../../..')))\nfrom curve_fit import curve_fit\nimport gradio as gr\nimport pandas as pd\nimport numpy as np\nimport json\n\ndef run_curve_fit(model, xdata, ydata, p_zero, bounds_lower, bounds_upper, method):\n    # Convert DataFrames to lists\n    xdata_list = xdata.values.tolist() if xdata is not None and not xdata.empty else None\n    ydata_list = ydata.values.tolist() if ydata is not None and not ydata.empty else None\n    p_zero_list = p_zero.values.tolist() if p_zero is not None and not p_zero.empty else None\n    bounds_lower_list = bounds_lower.values.tolist() if bounds_lower is not None and not bounds_lower.empty else None\n    bounds_upper_list = bounds_upper.values.tolist() if bounds_upper is not None and not bounds_upper.empty else None\n    method_str = method if method else None\n    result = curve_fit(model, xdata_list, ydata_list, p_zero_list, bounds_lower_list, bounds_upper_list, method_str)\n    # If result is a list of lists, show as DataFrame; else show as string\n    if isinstance(result, list):\n        try:\n            return pd.DataFrame(result)\n        except Exception:\n            return str(result)\n    return str(result)\n\ndef load_demo_examples():\n    test_cases_path = os.path.join(os.path.dirname(__file__), \"test_cases.json\")\n    with open(test_cases_path, \"r\", encoding=\"utf-8\") as f:\n        cases = json.load(f)\n    examples = []\n    for case in cases:\n        if case.get(\"demo\"):\n            args = case[\"arguments\"]\n            model = args.get(\"model\", \"\")\n            xdata = pd.DataFrame(args.get(\"xdata\", []))\n            ydata = pd.DataFrame(args.get(\"ydata\", []))\n            p0 = pd.DataFrame(args.get(\"p0\", []))\n            bounds_lower = pd.DataFrame(args.get(\"bounds_lower\", [])) if \"bounds_lower\" in args else None\n            bounds_upper = pd.DataFrame(args.get(\"bounds_upper\", [])) if \"bounds_upper\" in args else None\n            method = args.get(\"method\", \"\")\n            examples.append([\n                model,\n                xdata,\n                ydata,\n                p0,\n                bounds_lower,\n                bounds_upper,\n                method\n            ])\n    return examples\n\nexamples = load_demo_examples()\n\nwith gr.Blocks() as demo:\n    gr.Markdown(\"\"\"\n    # Curve Fit Demo\n    Fit a mathematical model to your data using non-linear least squares. Enter your model as a Python expression (e.g., `a * x + b`), provide your data, and set initial guesses for the parameters. Optionally, specify parameter bounds and the optimization method. Use the demo examples below to see typical use cases.\n    \"\"\")\n    with gr.Row():\n        model = gr.Textbox(label=\"Model (Python expression, e.g. a * x + b)\")\n    with gr.Row():\n        xdata = gr.Dataframe(label=\"x data (column vector)\", headers=None, datatype=\"number\", row_count=(1, \"dynamic\"), col_count=(1, \"fixed\"))\n        ydata = gr.Dataframe(label=\"y data (column vector)\", headers=None, datatype=\"number\", row_count=(1, \"dynamic\"), col_count=(1, \"fixed\"))\n    with gr.Row():\n        p_zero = gr.Dataframe(label=\"Initial parameter guesses (row)\", headers=None, datatype=\"number\", row_count=(1, \"fixed\"), col_count=(1, \"dynamic\"))\n    with gr.Row():\n        bounds_lower = gr.Dataframe(label=\"Lower bounds (row, optional)\", headers=None, datatype=\"number\", row_count=(1, \"fixed\"), col_count=(1, \"dynamic\"), visible=True)\n        bounds_upper = gr.Dataframe(label=\"Upper bounds (row, optional)\", headers=None, datatype=\"number\", row_count=(1, \"fixed\"), col_count=(1, \"dynamic\"), visible=True)\n    with gr.Row():\n        method = gr.Textbox(label=\"Method (trf, dogbox, lm)\", value=\"trf\")\n    output = gr.Dataframe(label=\"Fitted Parameters (row)\")\n    submit = gr.Button(\"Run Curve Fit\")\n    submit.click(run_curve_fit, inputs=[model, xdata, ydata, p_zero, bounds_lower, bounds_upper, method], outputs=output)\n    gr.Examples(\n        examples=examples,\n        inputs=[model, xdata, ydata, p_zero, bounds_lower, bounds_upper, method],\n        outputs=output,\n        label=\"Demo Examples\"\n    )\n\ndemo.launch()\n",
    "entrypoint": true
  },
  {
    "name": "curve_fit.py",
    "content": "import numpy as np\nfrom scipy.optimize import curve_fit as scipy_curve_fit\nimport math\n\nSAFE_GLOBALS = {k: getattr(math, k) for k in dir(math) if not k.startswith(\"_\")}\nSAFE_GLOBALS[\"np\"] = np\nSAFE_GLOBALS[\"numpy\"] = np\nSAFE_GLOBALS[\"exp\"] = np.exp\nSAFE_GLOBALS[\"log\"] = np.log\nSAFE_GLOBALS[\"sin\"] = np.sin\nSAFE_GLOBALS[\"cos\"] = np.cos\nSAFE_GLOBALS[\"tan\"] = np.tan\nSAFE_GLOBALS[\"abs\"] = abs\nSAFE_GLOBALS[\"pow\"] = pow\n\n\ndef curve_fit(model, xdata, ydata, p_zero, bounds_lower=None, bounds_upper=None, method=None):\n    \"\"\"\n    Fits a model to data using scipy.optimize.curve_fit.\n\n    Args:\n        model (str): Model function as a string, e.g., \"a * x + b\"\n        xdata (list): 2D list of x values\n        ydata (list): 2D list of y values\n        p_zero (list): 2D list of initial parameter guesses\n        bounds_lower (list, optional): 2D list of lower bounds\n        bounds_upper (list, optional): 2D list of upper bounds\n        method (str, optional): Optimization method\n\n    Returns:\n        2D list: Fitted parameter values as a single row, or error message string\n    \"\"\"\n    try:\n        x = np.array(xdata).flatten()\n        y = np.array(ydata).flatten()\n        p_zero = np.array(p_zero).flatten()\n        n_params = len(p_zero)\n\n        import re\n        param_names = re.findall(r'\\b[a-zA-Z_]\\w*\\b', model)\n        param_names = [name for name in param_names if name not in (\"x\", \"exp\", \"log\", \"sin\", \"cos\", \"tan\", \"abs\", \"pow\")]\n        param_names = list(dict.fromkeys(param_names))\n        if len(param_names) != n_params:\n            return f\"Number of initial guesses (p_zero) does not match number of parameters in model: {param_names}\"\n\n        def model_func(x, *params):\n            local_dict = dict(zip(param_names, params))\n            local_dict[\"x\"] = x\n            try:\n                return eval(model, SAFE_GLOBALS, local_dict)\n            except Exception as e:\n                raise ValueError(f\"Model evaluation error: {e}\")\n\n        bounds = (-np.inf, np.inf)\n        if bounds_lower is not None and bounds_upper is not None:\n            bounds = (np.array(bounds_lower).flatten(), np.array(bounds_upper).flatten())\n\n        fit_method = method if method is not None else 'trf'\n        if fit_method not in ('trf', 'dogbox', 'lm'):\n            return \"`method` must be 'trf', 'dogbox' or 'lm'.\"\n\n        popt, _ = scipy_curve_fit(model_func, x, y, p0=p_zero, bounds=bounds, method=fit_method, maxfev=10000)\n        return [popt.tolist()]\n    except Exception as e:\n        return str(e)\n"
  },
  {
    "name": "test_cases.json",
    "content": "[\n    {\n        \"id\": \"demo_linear_fit\",\n        \"description\": \"Fit a straight line to data (y = a * x + b)\",\n        \"arguments\": {\n            \"model\": \"a * x + b\",\n            \"xdata\": [\n                [\n                    1\n                ],\n                [\n                    2\n                ],\n                [\n                    3\n                ]\n            ],\n            \"ydata\": [\n                [\n                    2\n                ],\n                [\n                    4\n                ],\n                [\n                    6\n                ]\n            ],\n            \"p_zero\": [\n                [\n                    1,\n                    1\n                ]\n            ]\n        },\n        \"expected_rows\": 1,\n        \"demo\": true\n    },\n    {\n        \"id\": \"demo_exponential_fit\",\n        \"description\": \"Fit an exponential model (y = a * exp(b * x))\",\n        \"arguments\": {\n            \"model\": \"a * exp(b * x)\",\n            \"xdata\": [\n                [\n                    1\n                ],\n                [\n                    2\n                ],\n                [\n                    3\n                ]\n            ],\n            \"ydata\": [\n                [\n                    2.7\n                ],\n                [\n                    7.4\n                ],\n                [\n                    20.1\n                ]\n            ],\n            \"p_zero\": [\n                [\n                    1,\n                    1\n                ]\n            ]\n        },\n        \"expected_rows\": 1,\n        \"demo\": true\n    },\n    {\n        \"id\": \"bounds_test\",\n        \"description\": \"Fit with parameter bounds (a >= 0, b >= 0)\",\n        \"arguments\": {\n            \"model\": \"a * x + b\",\n            \"xdata\": [\n                [\n                    1\n                ],\n                [\n                    2\n                ],\n                [\n                    3\n                ]\n            ],\n            \"ydata\": [\n                [\n                    2\n                ],\n                [\n                    4\n                ],\n                [\n                    6\n                ]\n            ],\n            \"p_zero\": [\n                [\n                    1,\n                    1\n                ]\n            ],\n            \"bounds_lower\": [\n                [\n                    0,\n                    0\n                ]\n            ],\n            \"bounds_upper\": [\n                [\n                    10,\n                    10\n                ]\n            ]\n        },\n        \"expected_rows\": 1,\n        \"demo\": true\n    },\n    {\n        \"id\": \"method_test\",\n        \"description\": \"Fit using dogbox method\",\n        \"arguments\": {\n            \"model\": \"a * x + b\",\n            \"xdata\": [\n                [\n                    1\n                ],\n                [\n                    2\n                ],\n                [\n                    3\n                ]\n            ],\n            \"ydata\": [\n                [\n                    2\n                ],\n                [\n                    4\n                ],\n                [\n                    6\n                ]\n            ],\n            \"p_zero\": [\n                [\n                    1,\n                    1\n                ]\n            ],\n            \"method\": \"dogbox\"\n        },\n        \"expected_rows\": 1,\n        \"demo\": false\n    },\n    {\n        \"id\": \"error_param_mismatch\",\n        \"description\": \"Error if p_zero does not match number of parameters\",\n        \"arguments\": {\n            \"model\": \"a * x + b\",\n            \"xdata\": [\n                [\n                    1\n                ],\n                [\n                    2\n                ],\n                [\n                    3\n                ]\n            ],\n            \"ydata\": [\n                [\n                    2\n                ],\n                [\n                    4\n                ],\n                [\n                    6\n                ]\n            ],\n            \"p_zero\": [\n                [\n                    1\n                ]\n            ]\n        },\n        \"expected_rows\": 1,\n        \"demo\": false\n    },\n    {\n        \"id\": \"error_invalid_model\",\n        \"description\": \"Error if model string is invalid\",\n        \"arguments\": {\n            \"model\": \"a ** x + \",\n            \"xdata\": [\n                [\n                    1\n                ],\n                [\n                    2\n                ],\n                [\n                    3\n                ]\n            ],\n            \"ydata\": [\n                [\n                    2\n                ],\n                [\n                    4\n                ],\n                [\n                    6\n                ]\n            ],\n            \"p_zero\": [\n                [\n                    1,\n                    1\n                ]\n            ]\n        },\n        \"expected_rows\": 1,\n        \"demo\": false\n    }\n]"
  }
] } />
### LEAST_SQUARES

<GradioLiteDemo files={ [
  {
    "name": "gradio_least_squares.py",
    "content": "import sys\nimport os\nsys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '../../..')))\nfrom functions.optimization.least_squares.least_squares import least_squares\nimport gradio as gr\nimport pandas as pd\nimport numpy as np\nimport json\n\ndef run_least_squares(model, xdata, ydata, p_zero, bounds_lower, bounds_upper, method):\n    # Convert DataFrames to lists\n    xdata_list = xdata.values.tolist() if xdata is not None and not xdata.empty else None\n    ydata_list = ydata.values.tolist() if ydata is not None and not ydata.empty else None\n    p_zero_list = p_zero.values.tolist() if p_zero is not None and not p_zero.empty else None\n    bounds_lower_list = bounds_lower.values.tolist() if bounds_lower is not None and not bounds_lower.empty else None\n    bounds_upper_list = bounds_upper.values.tolist() if bounds_upper is not None and not bounds_upper.empty else None\n    method_str = method if method else None\n    result = least_squares(model, xdata_list, ydata_list, p_zero_list, bounds_lower_list, bounds_upper_list, method_str)\n    # If result is a list of lists, show as DataFrame; else show as string\n    if isinstance(result, list):\n        try:\n            return pd.DataFrame(result)\n        except Exception:\n            return str(result)\n    return str(result)\n\ndef load_demo_examples():\n    test_cases_path = os.path.join(os.path.dirname(__file__), \"test_cases.json\")\n    with open(test_cases_path, \"r\", encoding=\"utf-8\") as f:\n        cases = json.load(f)\n    examples = []\n    for case in cases:\n        if case.get(\"demo\"):\n            args = case[\"arguments\"]\n            model = args.get(\"model\", \"\")\n            xdata = pd.DataFrame(args.get(\"xdata\", []))\n            ydata = pd.DataFrame(args.get(\"ydata\", []))\n            p0 = pd.DataFrame(args.get(\"p0\", []))\n            bounds_lower = pd.DataFrame(args.get(\"bounds_lower\", [])) if \"bounds_lower\" in args else None\n            bounds_upper = pd.DataFrame(args.get(\"bounds_upper\", [])) if \"bounds_upper\" in args else None\n            method = args.get(\"method\", \"\")\n            examples.append([\n                model,\n                xdata,\n                ydata,\n                p0,\n                bounds_lower,\n                bounds_upper,\n                method\n            ])\n    return examples\n\nexamples = load_demo_examples()\n\nwith gr.Blocks() as demo:\n    gr.Markdown(\"\"\"\n    # Least Squares Demo\n    Fit a mathematical model to your data using nonlinear least squares. Enter your model as a Python expression (e.g., `a * x + b`), provide your data, and set initial guesses for the parameters. Optionally, specify parameter bounds and the optimization method. Use the demo examples below to see typical use cases.\n    \"\"\")\n    with gr.Row():\n        model = gr.Textbox(label=\"Model (Python expression, e.g. a * x + b)\")\n    with gr.Row():\n        xdata = gr.Dataframe(label=\"x data (column vector)\", headers=None, datatype=\"number\", row_count=(1, \"dynamic\"), col_count=(1, \"fixed\"))\n        ydata = gr.Dataframe(label=\"y data (column vector)\", headers=None, datatype=\"number\", row_count=(1, \"dynamic\"), col_count=(1, \"fixed\"))\n    with gr.Row():\n        p_zero = gr.Dataframe(label=\"Initial parameter guesses (row)\", headers=None, datatype=\"number\", row_count=(1, \"fixed\"), col_count=(1, \"dynamic\"))\n    with gr.Row():\n        bounds_lower = gr.Dataframe(label=\"Lower bounds (row, optional)\", headers=None, datatype=\"number\", row_count=(1, \"fixed\"), col_count=(1, \"dynamic\"), visible=True)\n        bounds_upper = gr.Dataframe(label=\"Upper bounds (row, optional)\", headers=None, datatype=\"number\", row_count=(1, \"fixed\"), col_count=(1, \"dynamic\"), visible=True)\n    with gr.Row():\n        method = gr.Textbox(label=\"Method (trf, dogbox, lm)\", value=\"trf\")\n    output = gr.Dataframe(label=\"Fitted Parameters (row)\")\n    submit = gr.Button(\"Run Least Squares\")\n    submit.click(run_least_squares, inputs=[model, xdata, ydata, p_zero, bounds_lower, bounds_upper, method], outputs=output)\n    gr.Examples(\n        examples=examples,\n        inputs=[model, xdata, ydata, p_zero, bounds_lower, bounds_upper, method],\n        outputs=output,\n        label=\"Demo Examples\"\n    )\n\ndemo.launch()\n",
    "entrypoint": true
  },
  {
    "name": "least_squares.py",
    "content": "import numpy as np\nfrom scipy.optimize import least_squares as scipy_least_squares\nimport math\n\n# Allow safe evaluation of model strings\nSAFE_GLOBALS = {k: getattr(math, k) for k in dir(math) if not k.startswith(\"_\")}\nSAFE_GLOBALS[\"np\"] = np\nSAFE_GLOBALS[\"numpy\"] = np\nSAFE_GLOBALS[\"exp\"] = np.exp\nSAFE_GLOBALS[\"log\"] = np.log\nSAFE_GLOBALS[\"sin\"] = np.sin\nSAFE_GLOBALS[\"cos\"] = np.cos\nSAFE_GLOBALS[\"tan\"] = np.tan\nSAFE_GLOBALS[\"abs\"] = abs\nSAFE_GLOBALS[\"pow\"] = pow\n\n\ndef least_squares(model, xdata, ydata, p_zero, bounds_lower=None, bounds_upper=None, method=None):\n    \"\"\"\n    Fits a model to data using nonlinear least squares.\n\n    Args:\n        model (str): Model function as a string, e.g., \"a * x + b\"\n        xdata (list): 2D list of x values\n        ydata (list): 2D list of y values\n        p_zero (list): 2D list of initial parameter guesses\n        bounds_lower (list, optional): 2D list of lower bounds\n        bounds_upper (list, optional): 2D list of upper bounds\n        method (str, optional): Optimization method\n\n    Returns:\n        2D list: Fitted parameter values as a single row, or error message string\n    \"\"\"\n    try:\n        # Flatten xdata, ydata, p_zero, bounds\n        x = np.array(xdata).flatten()\n        y = np.array(ydata).flatten()\n        p_zero = np.array(p_zero).flatten()\n        n_params = len(p_zero)\n\n        # Extract parameter names from model string\n        import re\n        param_names = re.findall(r'\\b[a-zA-Z_]\\w*\\b', model)\n        param_names = [name for name in param_names if name not in (\"x\", \"exp\", \"log\", \"sin\", \"cos\", \"tan\", \"abs\", \"pow\")]\n        param_names = list(dict.fromkeys(param_names))  # Remove duplicates, preserve order\n        if len(param_names) != n_params:\n            return f\"Number of initial guesses (p_zero) does not match number of parameters in model: {param_names}\"\n\n        # Prepare bounds\n        if bounds_lower is not None and bounds_upper is not None:\n            bounds = (np.array(bounds_lower).flatten(), np.array(bounds_upper).flatten())\n        else:\n            bounds = (-np.inf, np.inf)\n\n        # Build residuals function\n        def residuals(params):\n            local_dict = dict(zip(param_names, params))\n            local_dict[\"x\"] = x\n            try:\n                y_pred = eval(model, SAFE_GLOBALS, local_dict)\n            except Exception as e:\n                raise ValueError(f\"Model evaluation error: {e}\")\n            return y_pred - y\n\n        # Run least squares\n        # If method is None, use 'trf' (default for scipy_least_squares)\n        lsq_method = method if method is not None else 'trf'\n        if lsq_method not in ('trf', 'dogbox', 'lm'):\n            return \"`method` must be 'trf', 'dogbox' or 'lm'.\"\n        result = scipy_least_squares(residuals, p_zero, bounds=bounds, method=lsq_method)\n        if not result.success:\n            return f\"Fit failed: {result.message}\"\n        return [result.x.tolist()]\n    except Exception as e:\n        return str(e)\n"
  },
  {
    "name": "test_cases.json",
    "content": "[\n    {\n        \"id\": \"demo_linear_fit\",\n        \"description\": \"Fit a straight line to data (y = a * x + b)\",\n        \"arguments\": {\n            \"model\": \"a * x + b\",\n            \"xdata\": [\n                [\n                    1\n                ],\n                [\n                    2\n                ],\n                [\n                    3\n                ]\n            ],\n            \"ydata\": [\n                [\n                    2\n                ],\n                [\n                    4\n                ],\n                [\n                    6\n                ]\n            ],\n            \"p_zero\": [\n                [\n                    1,\n                    1\n                ]\n            ]\n        },\n        \"expected_rows\": 1,\n        \"demo\": true\n    },\n    {\n        \"id\": \"demo_exponential_fit\",\n        \"description\": \"Fit an exponential model (y = a * exp(b * x))\",\n        \"arguments\": {\n            \"model\": \"a * exp(b * x)\",\n            \"xdata\": [\n                [\n                    1\n                ],\n                [\n                    2\n                ],\n                [\n                    3\n                ]\n            ],\n            \"ydata\": [\n                [\n                    2.7\n                ],\n                [\n                    7.4\n                ],\n                [\n                    20.1\n                ]\n            ],\n            \"p_zero\": [\n                [\n                    1,\n                    1\n                ]\n            ]\n        },\n        \"expected_rows\": 1,\n        \"demo\": true\n    },\n    {\n        \"id\": \"bounds_test\",\n        \"description\": \"Fit with parameter bounds (a >= 0, b >= 0)\",\n        \"arguments\": {\n            \"model\": \"a * x + b\",\n            \"xdata\": [\n                [\n                    1\n                ],\n                [\n                    2\n                ],\n                [\n                    3\n                ]\n            ],\n            \"ydata\": [\n                [\n                    2\n                ],\n                [\n                    4\n                ],\n                [\n                    6\n                ]\n            ],\n            \"p_zero\": [\n                [\n                    1,\n                    1\n                ]\n            ],\n            \"bounds_lower\": [\n                [\n                    0,\n                    0\n                ]\n            ],\n            \"bounds_upper\": [\n                [\n                    10,\n                    10\n                ]\n            ]\n        },\n        \"expected_rows\": 1,\n        \"demo\": true\n    },\n    {\n        \"id\": \"method_test\",\n        \"description\": \"Fit using dogbox method\",\n        \"arguments\": {\n            \"model\": \"a * x + b\",\n            \"xdata\": [\n                [\n                    1\n                ],\n                [\n                    2\n                ],\n                [\n                    3\n                ]\n            ],\n            \"ydata\": [\n                [\n                    2\n                ],\n                [\n                    4\n                ],\n                [\n                    6\n                ]\n            ],\n            \"p_zero\": [\n                [\n                    1,\n                    1\n                ]\n            ],\n            \"method\": \"dogbox\"\n        },\n        \"expected_rows\": 1,\n        \"demo\": false\n    },\n    {\n        \"id\": \"error_param_mismatch\",\n        \"description\": \"Error if p_zero does not match number of parameters\",\n        \"arguments\": {\n            \"model\": \"a * x + b\",\n            \"xdata\": [\n                [\n                    1\n                ],\n                [\n                    2\n                ],\n                [\n                    3\n                ]\n            ],\n            \"ydata\": [\n                [\n                    2\n                ],\n                [\n                    4\n                ],\n                [\n                    6\n                ]\n            ],\n            \"p_zero\": [\n                [\n                    1\n                ]\n            ]\n        },\n        \"expected_rows\": 1,\n        \"demo\": false\n    },\n    {\n        \"id\": \"error_invalid_model\",\n        \"description\": \"Error if model string is invalid\",\n        \"arguments\": {\n            \"model\": \"a ** x + \",\n            \"xdata\": [\n                [\n                    1\n                ],\n                [\n                    2\n                ],\n                [\n                    3\n                ]\n            ],\n            \"ydata\": [\n                [\n                    2\n                ],\n                [\n                    4\n                ],\n                [\n                    6\n                ]\n            ],\n            \"p_zero\": [\n                [\n                    1,\n                    1\n                ]\n            ]\n        },\n        \"expected_rows\": 1,\n        \"demo\": false\n    }\n]"
  }
] } />
### LINEAR_ASSIGNMENT

<GradioLiteDemo files={ [
  {
    "name": "gradio_linear_assignment.py",
    "content": "import sys\nimport os\nsys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '../../..')))\nfrom functions.optimization.linear_assignment.linear_assignment import linear_assignment\nimport gradio as gr\nimport pandas as pd\nimport json\n\ndef run_linear_assignment(cost_matrix):\n    # Convert DataFrame to list\n    cost_matrix_list = cost_matrix.values.tolist() if cost_matrix is not None and not cost_matrix.empty else None\n    result = linear_assignment(cost_matrix_list)\n    if isinstance(result, list):\n        try:\n            return pd.DataFrame(result, columns=[\"Row\", \"Col\"])\n        except Exception:\n            return str(result)\n    return str(result)\n\ndef load_demo_examples():\n    test_cases_path = os.path.join(os.path.dirname(__file__), \"test_cases.json\")\n    with open(test_cases_path, \"r\", encoding=\"utf-8\") as f:\n        cases = json.load(f)\n    examples = []\n    for case in cases:\n        if case.get(\"demo\"):\n            args = case[\"arguments\"]\n            cost_matrix = pd.DataFrame(args.get(\"cost_matrix\", []))\n            examples.append([\n                cost_matrix\n            ])\n    return examples\n\nexamples = load_demo_examples()\n\nwith gr.Blocks() as demo:\n    gr.Markdown(\"\"\"\n    # Linear Assignment (Hungarian Algorithm) Demo\n    Enter a cost matrix (2D table). The algorithm will assign rows to columns to minimize total cost. See demo examples below.\n    \"\"\")\n    with gr.Row():\n        cost_matrix = gr.Dataframe(label=\"Cost Matrix (2D table)\", headers=None, datatype=\"number\", row_count=(1, \"dynamic\"), col_count=(1, \"dynamic\"))\n    output = gr.Dataframe(label=\"Assignments (Row, Col)\")\n    submit = gr.Button(\"Run Linear Assignment\")\n    submit.click(run_linear_assignment, inputs=[cost_matrix], outputs=output)\n    gr.Examples(\n        examples=examples,\n        inputs=[cost_matrix],\n        outputs=output,\n        label=\"Demo Examples\"\n    )\n\ndemo.launch()\n",
    "entrypoint": true
  },
  {
    "name": "linear_assignment.py",
    "content": "import numpy as np\ntry:\n    from scipy.optimize import linear_sum_assignment\nexcept ImportError:\n    linear_sum_assignment = None\n\ndef linear_assignment(cost_matrix):\n    \"\"\"\n    Solves the linear assignment problem (Hungarian algorithm) for a given cost matrix.\n\n    Args:\n        cost_matrix (list): 2D list representing the cost matrix.\n\n    Returns:\n        list: 2D list of [row, col] assignments, or error message string.\n    \"\"\"\n    if linear_sum_assignment is None:\n        return \"scipy is required but not available.\"\n    try:\n        arr = np.array(cost_matrix)\n        if arr.ndim != 2:\n            return \"Input must be a 2D list (matrix).\"\n        row_ind, col_ind = linear_sum_assignment(arr)\n        assignment = [[int(r), int(c)] for r, c in zip(row_ind, col_ind)]\n        return assignment\n    except Exception as e:\n        return str(e)\n"
  },
  {
    "name": "test_cases.json",
    "content": "[\n    {\n        \"id\": \"demo_basic_assignment\",\n        \"description\": \"Assign 3 workers to 3 tasks to minimize total cost.\",\n        \"arguments\": {\n            \"cost_matrix\": [\n                [\n                    4,\n                    1,\n                    3\n                ],\n                [\n                    2,\n                    0,\n                    5\n                ],\n                [\n                    3,\n                    2,\n                    2\n                ]\n            ]\n        },\n        \"expected_rows\": 3,\n        \"demo\": true\n    },\n    {\n        \"id\": \"rectangular_matrix\",\n        \"description\": \"Rectangular cost matrix (3x4).\",\n        \"arguments\": {\n            \"cost_matrix\": [\n                [\n                    10,\n                    19,\n                    8,\n                    15\n                ],\n                [\n                    10,\n                    18,\n                    7,\n                    17\n                ],\n                [\n                    13,\n                    16,\n                    9,\n                    14\n                ]\n            ]\n        },\n        \"expected_rows\": 3,\n        \"demo\": true\n    },\n    {\n        \"id\": \"invalid_input_not_2d\",\n        \"description\": \"Input is not a 2D list (should return error message).\",\n        \"arguments\": {\n            \"cost_matrix\": [\n                1,\n                2,\n                3\n            ]\n        },\n        \"expected_rows\": 1,\n        \"demo\": false\n    },\n    {\n        \"id\": \"empty_matrix\",\n        \"description\": \"Empty matrix input (should return error message).\",\n        \"arguments\": {\n            \"cost_matrix\": []\n        },\n        \"expected_rows\": 1,\n        \"demo\": false\n    },\n    {\n        \"id\": \"negative_costs\",\n        \"description\": \"Matrix with negative costs.\",\n        \"arguments\": {\n            \"cost_matrix\": [\n                [\n                    -1,\n                    -2,\n                    -3\n                ],\n                [\n                    -2,\n                    -4,\n                    -6\n                ],\n                [\n                    -3,\n                    -6,\n                    -9\n                ]\n            ]\n        },\n        \"expected_rows\": 3,\n        \"demo\": false\n    }\n]"
  }
] } />
### LINEAR_PROG

<GradioLiteDemo files={ [
  {
    "name": "gradio_linear_prog.py",
    "content": "import sys\nimport os\nsys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '../../..')))\nfrom functions.optimization.linear_prog.linear_prog import linear_prog\nimport gradio as gr\nimport pandas as pd\nimport json\n\ndef run_linear_prog(c, A_ub, b_ub, A_eq, b_eq, bounds, method):\n    # Convert all inputs to 2D lists or scalars as required by linear_prog\n    def to_2d(val):\n        if val is None or val == \"\":\n            return None\n        if isinstance(val, (int, float)):\n            return val\n        if isinstance(val, str):\n            try:\n                parsed = eval(val)\n                if isinstance(parsed, (int, float)):\n                    return parsed\n                if isinstance(parsed, list):\n                    return parsed\n            except Exception:\n                return val\n        return val\n    c = to_2d(c)\n    A_ub = to_2d(A_ub)\n    b_ub = to_2d(b_ub)\n    A_eq = to_2d(A_eq)\n    b_eq = to_2d(b_eq)\n    bounds = to_2d(bounds)\n    method = method if method else None\n    result = linear_prog(c, A_ub, b_ub, A_eq, b_eq, bounds, method)\n    return result\n\ndef load_demo_examples():\n    test_cases_path = os.path.join(os.path.dirname(__file__), \"test_cases.json\")\n    with open(test_cases_path, \"r\", encoding=\"utf-8\") as f:\n        cases = json.load(f)\n    examples = []\n    for case in cases:\n        if case.get(\"demo\"):\n            args = case[\"arguments\"]\n            c = pd.DataFrame([args.get(\"c\", [])])\n            A_ub = pd.DataFrame(args.get(\"A_ub\", [])) if \"A_ub\" in args else None\n            b_ub = pd.DataFrame([args.get(\"b_ub\", [])]) if \"b_ub\" in args else None\n            A_eq = pd.DataFrame(args.get(\"A_eq\", [])) if \"A_eq\" in args else None\n            b_eq = pd.DataFrame([args.get(\"b_eq\", [])]) if \"b_eq\" in args else None\n            bounds = pd.DataFrame(args.get(\"bounds\", [])) if \"bounds\" in args else None\n            method = args.get(\"method\", \"\")\n            examples.append([\n                c,\n                A_ub,\n                b_ub,\n                A_eq,\n                b_eq,\n                bounds,\n                method\n            ])\n    return examples\n\nexamples = load_demo_examples()\n\ndesc = \"\"\"\n# LINEAR_PROG Gradio Demo\\n\nEnter your LP problem as 2D lists (e.g., [[3,5]] for c, [[-1,-2],[-2,-1]] for A_ub, etc.) or scalars.\\n\nReturns a 2D list [[x1, x2, ...], fun] for success, or a 2D list or scalar string for errors.\n\"\"\"\n\nwith gr.Blocks() as demo:\n    gr.Markdown(\"\"\"\n    # Linear Programming Demo\n    Solve linear programming problems (minimize c^T x) with optional constraints. Enter your coefficients and constraints as tables. For b_ub and b_eq, enter as a single column (2D list shape (m, 1)). See demo examples below.\n    \"\"\")\n    with gr.Row():\n        c = gr.Dataframe(label=\"Objective Coefficients c (row)\", headers=None, datatype=\"number\", row_count=(1, \"fixed\"), col_count=(1, \"dynamic\"))\n    with gr.Row():\n        A_ub = gr.Dataframe(label=\"A_ub (Inequality LHS, optional)\", headers=None, datatype=\"number\", row_count=(1, \"dynamic\"), col_count=(1, \"dynamic\"))\n        b_ub = gr.Dataframe(label=\"b_ub (Inequality RHS, 2D col, shape (m, 1))\", headers=None, datatype=\"number\", row_count=(1, \"dynamic\"), col_count=(1, \"fixed\"))\n    with gr.Row():\n        A_eq = gr.Dataframe(label=\"A_eq (Equality LHS, optional)\", headers=None, datatype=\"number\", row_count=(1, \"dynamic\"), col_count=(1, \"dynamic\"))\n        b_eq = gr.Dataframe(label=\"b_eq (Equality RHS, 2D col, shape (m, 1))\", headers=None, datatype=\"number\", row_count=(1, \"dynamic\"), col_count=(1, \"fixed\"))\n    with gr.Row():\n        bounds = gr.Dataframe(label=\"Bounds (rows: variables, cols: [min, max])\", headers=None, datatype=\"number\", row_count=(1, \"dynamic\"), col_count=(2, \"fixed\"))\n        method = gr.Textbox(label=\"Method (e.g. highs)\", value=\"highs\")\n    output = gr.Dataframe(label=\"Solution (variables and optimal value)\")\n    submit = gr.Button(\"Run Linear Programming\")\n    submit.click(run_linear_prog, inputs=[c, A_ub, b_ub, A_eq, b_eq, bounds, method], outputs=output)\n    gr.Examples(\n        examples=examples,\n        inputs=[c, A_ub, b_ub, A_eq, b_eq, bounds, method],\n        outputs=output,\n        label=\"Demo Examples\"\n    )\n\ndemo.launch()\n",
    "entrypoint": true
  },
  {
    "name": "linear_prog.py",
    "content": "from scipy.optimize import linprog\nimport numpy as np\n\ndef linear_prog(c, A_ub=None, b_ub=None, A_eq=None, b_eq=None, bounds=None, method=None):\n    \"\"\"\n    Solves a linear programming problem using scipy.optimize.linprog.\n\n    Args:\n        c (2D list or scalar): Coefficients for the linear objective function to be minimized (as column vector or scalar).\n        A_ub (2D list or scalar, optional): 2D list for inequality constraints (A_ub x <= b_ub).\n        b_ub (2D list or scalar, optional): 2D list for inequality constraint bounds (each row is a single value).\n        A_eq (2D list or scalar, optional): 2D list for equality constraints (A_eq x == b_eq).\n        b_eq (2D list or scalar, optional): 2D list for equality constraint bounds (each row is a single value).\n        bounds (2D list or scalar, optional): 2D list of variable bounds [[min, max], ...].\n        method (str, optional): LP algorithm to use (e.g., 'highs').\n\n    Returns:\n        list: [[x1, x2, ...], fun] (optimal variable values and optimal value), or error string\n    \"\"\"\n    try:\n        # Helper to convert 2D list or scalar to 1D numpy array\n        def to_1d(arr, name):\n            if arr is None:\n                return None\n            if isinstance(arr, (int, float)):\n                return np.array([arr])\n            arr = np.array(arr)\n            if arr.ndim == 2 and (arr.shape[1] == 1 or arr.shape[0] == 1):\n                return arr.flatten()\n            return None\n        # Helper to convert 2D list or scalar to 2D numpy array\n        def to_2d(arr, name):\n            if arr is None:\n                return None\n            if isinstance(arr, (int, float)):\n                return np.array([[arr]])\n            arr = np.array(arr)\n            if arr.ndim == 2:\n                return arr\n            return None\n        # Validate and convert c\n        c_vec = to_1d(c, 'c')\n        if c_vec is None or not np.issubdtype(c_vec.dtype, np.number):\n            return \"c must be a 2D list (column or row vector) or scalar of numbers.\"\n        n_vars = c_vec.size\n        # Validate and convert A_ub\n        if A_ub is not None:\n            A_ub_mat = to_2d(A_ub, 'A_ub')\n            if A_ub_mat is None or A_ub_mat.shape[1] != n_vars:\n                return \"A_ub must be a 2D list with each row of length equal to c, or a scalar.\"\n        else:\n            A_ub_mat = None\n        # Validate and convert b_ub\n        if b_ub is not None:\n            b_ub_vec = to_1d(b_ub, 'b_ub')\n            if b_ub_vec is None:\n                return \"b_ub must be a 2D list (column or row vector) or scalar.\"\n        else:\n            b_ub_vec = None\n        # Validate and convert A_eq\n        if A_eq is not None:\n            A_eq_mat = to_2d(A_eq, 'A_eq')\n            if A_eq_mat is None or A_eq_mat.shape[1] != n_vars:\n                return \"A_eq must be a 2D list with each row of length equal to c, or a scalar.\"\n        else:\n            A_eq_mat = None\n        # Validate and convert b_eq\n        if b_eq is not None:\n            b_eq_vec = to_1d(b_eq, 'b_eq')\n            if b_eq_vec is None:\n                return \"b_eq must be a 2D list (column or row vector) or scalar.\"\n        else:\n            b_eq_vec = None\n        # Validate and convert bounds\n        if bounds is not None:\n            bounds_mat = to_2d(bounds, 'bounds')\n            if bounds_mat is None or bounds_mat.shape[1] != 2:\n                return \"bounds must be a 2D list of [min, max] pairs or a scalar.\"\n            bounds_list = [tuple(row) for row in bounds_mat]\n        else:\n            bounds_list = None\n        # Validate method\n        if method is not None and not isinstance(method, str):\n            return \"method must be a string or None.\"\n        lp_method = method if method is not None else 'highs'\n        result = linprog(\n            c_vec,\n            A_ub=A_ub_mat,\n            b_ub=b_ub_vec,\n            A_eq=A_eq_mat,\n            b_eq=b_eq_vec,\n            bounds=bounds_list,\n            method=lp_method\n        )\n        if not result.success:\n            return [[f\"Linear programming failed: {result.message}\"]]\n        # Always return a 2D list: [[x1, x2, ...], fun]\n        return [[*list(result.x), float(result.fun)]]\n    except Exception as e:\n        # Return a 2D list with a single error string (not a scalar)\n        return [[f\"Error during linear programming: {str(e)}\"]]\n"
  },
  {
    "name": "test_cases.json",
    "content": "[\n    {\n        \"id\": \"resource_allocation_min_cost\",\n        \"description\": \"Minimize 3x + 5y subject to x + 2y >= 8, 2x + y >= 8, x >= 0, y >= 0.\",\n        \"arguments\": {\n            \"c\": [\n                [\n                    3,\n                    5\n                ]\n            ],\n            \"A_ub\": [\n                [\n                    -1,\n                    -2\n                ],\n                [\n                    -2,\n                    -1\n                ]\n            ],\n            \"b_ub\": [\n                [\n                    -8\n                ],\n                [\n                    -8\n                ]\n            ],\n            \"bounds\": [\n                [\n                    0,\n                    null\n                ],\n                [\n                    0,\n                    null\n                ]\n            ]\n        },\n        \"expected_rows\": 1,\n        \"demo\": true\n    },\n    {\n        \"id\": \"diet_problem_max_protein\",\n        \"description\": \"Maximize x + y subject to x + 2y <= 10, x >= 0, y >= 0 (negate objective for minimization).\",\n        \"arguments\": {\n            \"c\": [\n                [\n                    -1,\n                    -1\n                ]\n            ],\n            \"A_ub\": [\n                [\n                    1,\n                    2\n                ]\n            ],\n            \"b_ub\": [\n                [\n                    10\n                ]\n            ],\n            \"bounds\": [\n                [\n                    0,\n                    null\n                ],\n                [\n                    0,\n                    null\n                ]\n            ]\n        },\n        \"expected_rows\": 1,\n        \"demo\": true\n    },\n    {\n        \"id\": \"infeasible_problem\",\n        \"description\": \"Infeasible problem: x >= 1, x <= 0.\",\n        \"arguments\": {\n            \"c\": [\n                [\n                    1\n                ]\n            ],\n            \"A_ub\": [\n                [\n                    -1\n                ],\n                [\n                    1\n                ]\n            ],\n            \"b_ub\": [\n                [\n                    -1\n                ],\n                [\n                    0\n                ]\n            ],\n            \"bounds\": [\n                [\n                    0,\n                    1\n                ]\n            ]\n        },\n        \"expect_error\": true,\n        \"expected_rows\": 1,\n        \"demo\": false\n    },\n    {\n        \"id\": \"invalid_input\",\n        \"description\": \"Invalid input: c is not a list.\",\n        \"arguments\": {\n            \"c\": \"not_a_list\"\n        },\n        \"expect_error\": true,\n        \"expected_rows\": 1,\n        \"demo\": false\n    }\n]"
  }
] } />
### MINIMIZE_MULTI

<GradioLiteDemo files={ [
  {
    "name": "gradio_minimize_multi.py",
    "content": "import sys\nimport os\nsys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '../../..')))\nfrom functions.optimization.minimize_multi.minimize_multi import minimize_multi\nimport gradio as gr\nimport pandas as pd\nimport json\n\ndef run_minimize_multi(func_expr, x_zero, bounds, method, constraints):\n    x_zero_list = x_zero.values.tolist() if x_zero is not None and not x_zero.empty else None\n    bounds_list = bounds.values.tolist() if bounds is not None and not bounds.empty else None\n    method_list = method.values.tolist() if method is not None and not method.empty else None\n    constraints_val = constraints.values.tolist() if constraints is not None and not constraints.empty else None\n    result = minimize_multi(func_expr, x_zero_list, bounds_list, method_list, constraints_val)\n    if isinstance(result, list):\n        try:\n            df = pd.DataFrame(result, columns=[f\"x{i+1}\" for i in range(len(result[0])-1)] + [\"Minimum Value\"])\n            return df\n        except Exception:\n            return str(result)\n    return str(result)\n\ndef load_demo_examples():\n    test_cases_path = os.path.join(os.path.dirname(__file__), \"test_cases_minimize_multi.json\")\n    with open(test_cases_path, \"r\", encoding=\"utf-8\") as f:\n        cases = json.load(f)\n    examples = []\n    for case in cases:\n        if case.get(\"demo\"):\n            args = case[\"arguments\"]\n            func_expr = args.get(\"func_expr\", \"\")\n            x0 = pd.DataFrame(args.get(\"x0\", []))\n            bounds = pd.DataFrame(args.get(\"bounds\", [])) if \"bounds\" in args else None\n            method = pd.DataFrame(args.get(\"method\", [])) if \"method\" in args else None\n            constraints = pd.DataFrame(args.get(\"constraints\", [])) if \"constraints\" in args else None\n            examples.append([\n                func_expr,\n                x0,\n                bounds,\n                method,\n                constraints\n            ])\n    return examples\n\nexamples = load_demo_examples()\n\nwith gr.Blocks() as demo:\n    gr.Markdown(\"\"\"\n    # Multivariate Minimization Demo\n    Minimize a multivariate function using scipy.optimize.minimize. Enter your function, initial guess, and optional bounds, method, and constraints. See demo examples below.\n    \"\"\")\n    with gr.Row():\n        func_expr = gr.Textbox(label=\"Function Expression (e.g. x[0]**2 + x[1]**2 + 3*x[0])\", lines=2)\n    with gr.Row():\n        x_zero = gr.Dataframe(label=\"Initial Guess x_zero (row)\", headers=None, datatype=\"number\", row_count=(1, \"fixed\"), col_count=(1, \"dynamic\"))\n    with gr.Row():\n        bounds = gr.Dataframe(label=\"Bounds (rows: variables, cols: [min, max])\", headers=None, datatype=\"number\", row_count=(1, \"dynamic\"), col_count=(2, \"fixed\"))\n        method = gr.Dataframe(label=\"Method (e.g. [['COBYLA']])\", headers=None, datatype=\"str\", row_count=(1, \"dynamic\"), col_count=(1, \"dynamic\"))\n        constraints = gr.Dataframe(label=\"Constraints (optional)\", headers=None, datatype=\"str\", row_count=(1, \"dynamic\"), col_count=(1, \"dynamic\"))\n    output = gr.Dataframe(label=\"Solution (variables and minimum value)\")\n    submit = gr.Button(\"Run Minimization\")\n    submit.click(run_minimize_multi, inputs=[func_expr, x_zero, bounds, method, constraints], outputs=output)\n    gr.Examples(\n        examples=examples,\n        inputs=[func_expr, x_zero, bounds, method, constraints],\n        outputs=output,\n        label=\"Demo Examples\"\n    )\n\ndemo.launch()\n",
    "entrypoint": true
  },
  {
    "name": "minimize_multi.py",
    "content": "# Minimize Multi (Multivariate)\n\nfrom scipy.optimize import minimize\nimport math\n\ndef minimize_multi(func_expr, x_zero=None, bounds=None, method=None, constraints=None):\n    \"\"\"\n    Minimizes a function using scipy.optimize.minimize.\n    \n    Args:\n        func_expr (str): A string representing the function to minimize, e.g., 'x[0]**2 + x[1]**2'.\n        x_zero (2D list, required): Initial guess for the variables, as a 2D list (e.g., [[0, 0]]).\n        bounds (2D list or None): Bounds for variables, as a 2D list (e.g., [[min1, max1], [min2, max2]]).\n        method (str or None): Optimization method supported by scipy.optimize.minimize.\n        constraints (dict, list, or None): Constraints definition for constrained optimization.\n    \n    Returns:\n        2D list: [[x0, x1, ..., fun]] where x is the location of minimum and fun is the minimum value, or a string with an error message\n    \"\"\"\n    # Input validation and normalization\n    if not isinstance(func_expr, str):\n        return \"func_expr must be a string.\"\n    # x_zero must be a 2D list with one row\n    if x_zero is None or not (isinstance(x_zero, list) and len(x_zero) > 0 and isinstance(x_zero[0], list)):\n        return \"x_zero (initial guess) must be provided as a 2D list, e.g., [[0, 0]].\"\n    x0_row = x_zero[0]\n    if not all(isinstance(v, (int, float)) for v in x0_row):\n        return \"x_zero (initial guess) must be a 2D list of numbers.\"\n    # bounds must be a 2D list or None\n    bounds_list = None\n    if bounds is not None:\n        if not (isinstance(bounds, list) and all(isinstance(b, (list, tuple)) and len(b) == 2 for b in bounds)):\n            return \"bounds must be a 2D list of (min, max) pairs or None.\"\n        bounds_list = [tuple(b) for b in bounds]\n    # method must be a 2D list or scalar or None\n    method_str = None\n    if method is not None:\n        if isinstance(method, list):\n            # Accept 2D list or 1D list\n            if len(method) > 0 and isinstance(method[0], list):\n                # 2D list: [[\"COBYLA\"]]\n                method_str = method[0][0] if len(method[0]) > 0 else None\n            elif len(method) > 0 and isinstance(method[0], str):\n                # 1D list: [\"COBYLA\"]\n                method_str = method[0]\n            else:\n                return \"method must be a string, 2D list, or None.\"\n        elif isinstance(method, str):\n            method_str = method\n        else:\n            return \"method must be a string, 2D list, or None.\"\n    # constraints can be 2D list, dict, list, or None\n    constraints_val = constraints\n    if constraints is not None:\n        if isinstance(constraints, list) and len(constraints) > 0 and isinstance(constraints[0], list):\n            # 2D list: treat as list of dicts\n            constraints_val = [item for item in constraints]\n        elif not isinstance(constraints, (dict, list)):\n            return \"constraints must be a dict, list, 2D list, or None.\"\n    if 'x' not in func_expr:\n        return \"Function expression must contain the variable 'x'.\"\n\n    def func(x):\n        try:\n            return eval(func_expr, {\"x\": x, \"math\": math})\n        except Exception as e:\n            # Return error string for invalid expressions\n            raise ValueError(f\"Error evaluating function expression: {str(e)}\")\n\n    kwargs = {}\n    if bounds_list is not None:\n        kwargs['bounds'] = bounds_list\n    if method_str is not None:\n        kwargs['method'] = method_str\n    if constraints_val is not None:\n        kwargs['constraints'] = constraints_val\n\n    try:\n        result = minimize(func, x0_row, **kwargs)\n        if not hasattr(result, 'x') or not hasattr(result, 'fun'):\n            return \"Error during minimization: Invalid result object.\"\n        if not result.success or not isinstance(result.fun, (int, float)) or result.fun == float('inf'):\n            # Try to extract error message if available\n            msg = getattr(result, 'message', None)\n            if msg:\n                return f\"Error during minimization: {msg}\"\n            return \"Error during minimization: Optimization failed.\"\n        x_list = [float(xi) for xi in result.x]\n        return [x_list + [float(result.fun)]]\n    except ValueError as ve:\n        return str(ve)\n    except Exception as e:\n        return f\"Error during minimization: {str(e)}\"\n"
  },
  {
    "name": "test_cases.json",
    "content": "[\n    {\n        \"id\": \"quadratic_2d_unbounded\",\n        \"description\": \"Minimize the quadratic cost function C(x) = x[0]**2 + x[1]**2 + 3*x[0] in Excel. Returns the x-values and minimum cost as a 2D list.\",\n        \"arguments\": {\n            \"func_expr\": \"x[0]**2 + x[1]**2 + 3*x[0]\",\n            \"x_zero\": [\n                [\n                    0,\n                    0\n                ]\n            ]\n        },\n        \"expected_rows\": 1,\n        \"demo\": true\n    },\n    {\n        \"id\": \"bounded_minimum_2d\",\n        \"description\": \"Minimize f(x) = (x[0]-5)**2 + (x[1]-2)**2 in Excel, with x[0] in [0, 10] and x[1] in [0, 5]. Returns the x-values and minimum value as a 2D list.\",\n        \"arguments\": {\n            \"func_expr\": \"(x[0]-5)**2 + (x[1]-2)**2\",\n            \"x_zero\": [\n                [\n                    1,\n                    1\n                ]\n            ],\n            \"bounds\": [\n                [\n                    0,\n                    10\n                ],\n                [\n                    0,\n                    5\n                ]\n            ]\n        },\n        \"expected_rows\": 1,\n        \"demo\": true\n    },\n    {\n        \"id\": \"invalid_expression_2d\",\n        \"description\": \"Invalid function expression should raise an error.\",\n        \"arguments\": {\n            \"func_expr\": \"x[0]***2 + x[1] + 2\",\n            \"x_zero\": [\n                [\n                    0,\n                    0\n                ]\n            ]\n        },\n        \"expect_error\": true,\n        \"expected_rows\": 1,\n        \"demo\": false\n    },\n    {\n        \"id\": \"missing_x_2d\",\n        \"description\": \"Function expression without 'x' should raise an error.\",\n        \"arguments\": {\n            \"func_expr\": \"5 + 7\",\n            \"x_zero\": [\n                [\n                    0,\n                    0\n                ]\n            ]\n        },\n        \"expect_error\": true,\n        \"expected_rows\": 1,\n        \"demo\": false\n    },\n    {\n        \"id\": \"with_method_cobyla\",\n        \"description\": \"Minimize f(x) = (x[0]-1)**2 + (x[1]-2)**2 using COBYLA method (no bounds, unconstrained).\",\n        \"arguments\": {\n            \"func_expr\": \"(x[0]-1)**2 + (x[1]-2)**2\",\n            \"x_zero\": [\n                [\n                    0,\n                    0\n                ]\n            ],\n            \"method\": [\n                [\n                    \"COBYLA\"\n                ]\n            ]\n        },\n        \"expected_rows\": 1,\n        \"demo\": true\n    }\n]"
  }
] } />
### MINIMIZE_SCALAR

<GradioLiteDemo files={ [
  {
    "name": "gradio_minimize_scalar.py",
    "content": "import sys\nimport os\nsys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '../../..')))\nfrom functions.optimization.minimize_scalar.minimize_scalar import minimize_scalar_function\nimport gradio as gr\nimport pandas as pd\nimport json\n\ndef run_minimize_scalar(func_expr, bounds, method):\n    bounds_list = bounds.values.tolist() if bounds is not None and not bounds.empty else None\n    method_str = method if method else None\n    result = minimize_scalar_function(func_expr, bounds_list, method_str)\n    if isinstance(result, list):\n        try:\n            df = pd.DataFrame(result, columns=[\"x\", \"Minimum Value\"])\n            return df\n        except Exception:\n            return str(result)\n    return str(result)\n\ndef load_demo_examples():\n    test_cases_path = os.path.join(os.path.dirname(__file__), \"test_cases.json\")\n    with open(test_cases_path, \"r\", encoding=\"utf-8\") as f:\n        cases = json.load(f)\n    examples = []\n    for case in cases:\n        if case.get(\"demo\"):\n            args = case[\"arguments\"]\n            func_expr = args.get(\"func_expr\", \"\")\n            bounds = pd.DataFrame(args.get(\"bounds\", [])) if \"bounds\" in args else None\n            method = args.get(\"method\", \"\")\n            examples.append([\n                func_expr,\n                bounds,\n                method\n            ])\n    return examples\n\nexamples = load_demo_examples()\n\nwith gr.Blocks() as demo:\n    gr.Markdown(\"\"\"\n    # Scalar Minimization Demo\n    Minimize a scalar function using scipy.optimize.minimize_scalar. Enter your function, and optional bounds and method. See demo examples below.\n    \"\"\")\n    with gr.Row():\n        func_expr = gr.Textbox(label=\"Function Expression (e.g. x**2 + 3*x + 2)\", lines=2)\n    with gr.Row():\n        bounds = gr.Dataframe(label=\"Bounds (row: [min, max])\", headers=None, datatype=\"number\", row_count=(1, \"dynamic\"), col_count=(2, \"fixed\"))\n        method = gr.Textbox(label=\"Method (e.g. bounded)\", value=\"\")\n    output = gr.Dataframe(label=\"Solution (x and minimum value)\")\n    submit = gr.Button(\"Run Minimization\")\n    submit.click(run_minimize_scalar, inputs=[func_expr, bounds, method], outputs=output)\n    gr.Examples(\n        examples=examples,\n        inputs=[func_expr, bounds, method],\n        outputs=output,\n        label=\"Demo Examples\"\n    )\n\ndemo.launch()\n",
    "entrypoint": true
  },
  {
    "name": "minimize_scalar.py",
    "content": "# Minimize Scalar Function\n\nfrom scipy.optimize import minimize_scalar\nimport math\n\n\ndef minimize_scalar_function(func_expr, bounds=None, method=None):\n    \"\"\"\n    Minimizes a scalar function using scipy.optimize.minimize_scalar.\n\n    Args:\n        func_expr (str): A string representing the function to minimize, e.g., 'x**2 + 3*x + 2'.\n        bounds (list, optional): A 2D list [[min, max]] specifying the bounds for bounded methods.\n        method (str, optional): Optimization method: 'brent', 'bounded', or 'golden'.\n\n    Returns:\n        list: [[x, fun]] where x is the location of minimum and fun is the minimum value, or a string with an error message\n    \"\"\"\n    # Input validation for argument types\n    if not (isinstance(func_expr, str)):\n        return \"func_expr must be a string.\"\n    if bounds is not None:\n        if not (isinstance(bounds, list) and all(isinstance(b, list) and len(b) == 2 for b in bounds)):\n            return \"bounds must be a 2D list (list of [min, max] lists) or None.\"\n    if method is not None and not isinstance(method, str):\n        return \"method must be a string or None.\"\n\n    # Define the function from the string expression\n    def func(x):\n        return eval(func_expr, {\"x\": x, \"math\": math})\n\n    # Check if 'x' is present in the function expression\n    if 'x' not in func_expr:\n        return \"Function expression must contain the variable 'x'.\"\n\n    kwargs = {}\n    # Accept bounds as a 2D list [[min, max]] or as a scalar (not tuple)\n    if bounds is not None:\n        # If bounds is a 2D list (e.g., [[0, 10]]), extract min and max\n        if isinstance(bounds, list) and len(bounds) == 1 and isinstance(bounds[0], list) and len(bounds[0]) == 2:\n            min_val, max_val = bounds[0][0], bounds[0][1]\n            kwargs['bounds'] = [min_val, max_val]\n        else:\n            kwargs['bounds'] = bounds\n    if method is not None:\n        kwargs['method'] = method\n\n    try:\n        result = minimize_scalar(func, **kwargs)\n        # Return as a 2D list: [[x, fun]]\n        return [[float(result.x), float(result.fun)]]\n    except Exception as e:\n        return f\"Error during minimization: {str(e)}\"\n"
  },
  {
    "name": "test_cases.json",
    "content": "[\n    {\n        \"id\": \"quadratic_unbounded\",\n        \"description\": \"Minimize the quadratic cost function C(x) = x^2 + 3x + 2 in Excel. Returns the x-value and minimum cost as a 2D list.\",\n        \"arguments\": {\n            \"func_expr\": \"x**2 + 3*x + 2\"\n        },\n        \"expected_rows\": 1,\n        \"demo\": true\n    },\n    {\n        \"id\": \"bounded_minimum\",\n        \"description\": \"Minimize f(x) = (x-5)^2 + 10 in Excel, with x between 0 and 10. Returns the x-value and minimum value as a 2D list.\",\n        \"arguments\": {\n            \"func_expr\": \"(x-5)**2 + 10\",\n            \"bounds\": [\n                [\n                    0,\n                    10\n                ]\n            ],\n            \"method\": \"bounded\"\n        },\n        \"expected_rows\": 1,\n        \"demo\": true\n    },\n    {\n        \"id\": \"invalid_expression\",\n        \"description\": \"Invalid function expression should raise an error.\",\n        \"arguments\": {\n            \"func_expr\": \"x***2 + 3x + 2\"\n        },\n        \"expect_error\": true,\n        \"expected_rows\": 1,\n        \"demo\": false\n    },\n    {\n        \"id\": \"missing_x\",\n        \"description\": \"Function expression without 'x' should raise an error.\",\n        \"arguments\": {\n            \"func_expr\": \"5 + 7\"\n        },\n        \"expect_error\": true,\n        \"expected_rows\": 1,\n        \"demo\": false\n    }\n]"
  }
] } />
### QUADRATIC_ASSIGNMENT

<GradioLiteDemo files={ [
  {
    "name": "gradio_quadratic_assignment.py",
    "content": "import sys\nimport os\nsys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '../../..')))\nfrom functions.optimization.quadratic_assignment.quadratic_assignment import quadratic_assignment_func\nimport gradio as gr\nimport pandas as pd\nimport json\n\ndef run_quadratic_assignment(flow_matrix, distance_matrix):\n    flow_matrix_list = flow_matrix.values.tolist() if flow_matrix is not None and not flow_matrix.empty else None\n    distance_matrix_list = distance_matrix.values.tolist() if distance_matrix is not None and not distance_matrix.empty else None\n    result = quadratic_assignment_func(flow_matrix_list, distance_matrix_list)\n    if isinstance(result, list):\n        try:\n            return pd.DataFrame(result, columns=[\"Facility\", \"Location\"])\n        except Exception:\n            return str(result)\n    return str(result)\n\ndef load_demo_examples():\n    test_cases_path = os.path.join(os.path.dirname(__file__), \"test_cases.json\")\n    with open(test_cases_path, \"r\", encoding=\"utf-8\") as f:\n        cases = json.load(f)\n    examples = []\n    for case in cases:\n        if case.get(\"demo\"):\n            args = case[\"arguments\"]\n            flow_matrix = pd.DataFrame(args.get(\"flow_matrix\", []))\n            distance_matrix = pd.DataFrame(args.get(\"distance_matrix\", []))\n            examples.append([\n                flow_matrix,\n                distance_matrix\n            ])\n    return examples\n\nexamples = load_demo_examples()\n\nwith gr.Blocks() as demo:\n    gr.Markdown(\"\"\"\n    # Quadratic Assignment Problem (QAP) Demo\n    Enter flow and distance matrices (2D tables). The algorithm will assign facilities to locations to minimize total cost. See demo examples below.\n    \"\"\")\n    with gr.Row():\n        flow_matrix = gr.Dataframe(label=\"Flow Matrix (2D table)\", headers=None, datatype=\"number\", row_count=(1, \"dynamic\"), col_count=(1, \"dynamic\"))\n        distance_matrix = gr.Dataframe(label=\"Distance Matrix (2D table)\", headers=None, datatype=\"number\", row_count=(1, \"dynamic\"), col_count=(1, \"dynamic\"))\n    output = gr.Dataframe(label=\"Assignments (Facility, Location)\")\n    submit = gr.Button(\"Run Quadratic Assignment\")\n    submit.click(run_quadratic_assignment, inputs=[flow_matrix, distance_matrix], outputs=output)\n    gr.Examples(\n        examples=examples,\n        inputs=[flow_matrix, distance_matrix],\n        outputs=output,\n        label=\"Demo Examples\"\n    )\n\ndemo.launch()\n",
    "entrypoint": true
  },
  {
    "name": "quadratic_assignment.py",
    "content": "import numpy as np\ntry:\n    from scipy.optimize import quadratic_assignment\nexcept ImportError:\n    quadratic_assignment = None\n\ndef quadratic_assignment_func(flow_matrix, distance_matrix):\n    \"\"\"\n    Solves the quadratic assignment problem (QAP) for given flow and distance matrices.\n\n    Args:\n        flow_matrix (list): 2D list representing the flow between facilities.\n        distance_matrix (list): 2D list representing the distances between locations.\n\n    Returns:\n        list: 2D list of [facility, location] assignments, or error message string.\n    \"\"\"\n    if quadratic_assignment is None:\n        return \"scipy is required but not available.\"\n    try:\n        flow = np.array(flow_matrix)\n        dist = np.array(distance_matrix)\n        if flow.ndim != 2 or dist.ndim != 2:\n            return \"Both inputs must be 2D lists (matrices).\"\n        if flow.shape != dist.shape or flow.shape[0] != flow.shape[1]:\n            return \"Both matrices must be square and of the same size.\"\n        result = quadratic_assignment(flow, dist)\n        if not hasattr(result, 'col_ind'):\n            return str(result)\n        assignment = [[int(i), int(j)] for i, j in enumerate(result.col_ind)]\n        return assignment\n    except Exception as e:\n        return str(e)\n"
  },
  {
    "name": "test_cases.json",
    "content": "[\n    {\n        \"id\": \"demo_basic_qap\",\n        \"description\": \"Assign 3 facilities to 3 locations to minimize total cost.\",\n        \"arguments\": {\n            \"flow_matrix\": [\n                [\n                    0,\n                    5,\n                    2\n                ],\n                [\n                    5,\n                    0,\n                    3\n                ],\n                [\n                    2,\n                    3,\n                    0\n                ]\n            ],\n            \"distance_matrix\": [\n                [\n                    0,\n                    2,\n                    3\n                ],\n                [\n                    2,\n                    0,\n                    1\n                ],\n                [\n                    3,\n                    1,\n                    0\n                ]\n            ]\n        },\n        \"expected_rows\": 3,\n        \"demo\": true\n    },\n    {\n        \"id\": \"invalid_input_not_2d\",\n        \"description\": \"Input is not a 2D list (should return error message).\",\n        \"arguments\": {\n            \"flow_matrix\": [\n                1,\n                2,\n                3\n            ],\n            \"distance_matrix\": [\n                1,\n                2,\n                3\n            ]\n        },\n        \"expected_rows\": 1,\n        \"demo\": false\n    },\n    {\n        \"id\": \"invalid_shape\",\n        \"description\": \"Matrices are not square or not the same size (should return error message).\",\n        \"arguments\": {\n            \"flow_matrix\": [\n                [\n                    0,\n                    1\n                ],\n                [\n                    1,\n                    0\n                ]\n            ],\n            \"distance_matrix\": [\n                [\n                    0,\n                    2,\n                    3\n                ],\n                [\n                    2,\n                    0,\n                    1\n                ],\n                [\n                    3,\n                    1,\n                    0\n                ]\n            ]\n        },\n        \"expected_rows\": 1,\n        \"demo\": false\n    },\n    {\n        \"id\": \"empty_matrix\",\n        \"description\": \"Empty matrix input (should return error message).\",\n        \"arguments\": {\n            \"flow_matrix\": [],\n            \"distance_matrix\": []\n        },\n        \"expected_rows\": 1,\n        \"demo\": false\n    }\n]"
  }
] } />
## Text
### AI_ASK

<GradioLiteDemo files={ [
  {
    "name": "gradio_ai_ask.py",
    "content": "# Gradio demo for ai_ask\nimport gradio as gr\nimport pandas as pd\nfrom ai_ask import ai_ask\nimport json\nimport os\n\ndef run_ai_ask(prompt, data, temperature, max_tokens, model):\n    # Convert DataFrame to list of lists if not empty\n    data_list = data.values.tolist() if data is not None and not data.empty else None\n    return ai_ask(prompt, data=data_list, temperature=temperature, max_tokens=max_tokens, model=model)\n\n# Load demo examples from test_cases.json\ndef load_demo_examples():\n    test_cases_path = os.path.join(os.path.dirname(__file__), \"test_cases.json\")\n    with open(test_cases_path, \"r\", encoding=\"utf-8\") as f:\n        cases = json.load(f)\n    # Only include cases where demo is true\n    examples = []\n    for case in cases:\n        if case.get(\"demo\"):\n            args = case[\"arguments\"]\n            prompt = args.get(\"prompt\", \"\")\n            data = args.get(\"data\", None)\n            temperature = args.get(\"temperature\", 0.5)\n            max_tokens = args.get(\"max_tokens\", 250)\n            model = args.get(\"model\", \"mistral-small-latest\")\n            # Convert data to DataFrame if present\n            data_df = pd.DataFrame(data) if data is not None else None\n            examples.append([\n                prompt,\n                data_df,\n                temperature,\n                max_tokens,\n                model\n            ])\n    return examples\n\nexamples = load_demo_examples()\n\nwith gr.Blocks() as demo:\n    gr.Markdown(\"\"\"\n    This demo allows you to interact with the AI Ask function. Enter a prompt and, optionally, provide tabular data for the AI to analyze or summarize. Adjust the temperature for creativity, set the maximum number of tokens for the response, and specify the model if desired. Use the demo examples below to see typical use cases.\n    \"\"\")\n    with gr.Row():\n        prompt = gr.Textbox(label=\"Prompt\", lines=2)\n    with gr.Row():\n        data = gr.Dataframe(label=\"Data (optional)\", headers=None, datatype=\"str\", row_count=(1, \"dynamic\"), col_count=(1, \"dynamic\"))\n    with gr.Row():\n        temperature = gr.Slider(0.0, 2.0, value=0.5, step=0.01, label=\"Temperature\")\n        max_tokens = gr.Number(value=250, label=\"Max Tokens\")\n        model = gr.Textbox(value=\"mistral-small-latest\", label=\"Model\")\n    output = gr.Textbox(label=\"AI Response\")\n    submit = gr.Button(\"Run\")\n    submit.click(run_ai_ask, inputs=[prompt, data, temperature, max_tokens, model], outputs=output)\n    gr.Examples(\n        examples=examples,\n        inputs=[prompt, data, temperature, max_tokens, model],\n        outputs=output,\n        label=\"Demo Examples\"\n    )\n\ndemo.launch()\n",
    "entrypoint": true
  },
  {
    "name": "ai_ask.py",
    "content": "import requests\nimport json\n\ndef ai_ask(prompt, data=None, temperature=0.5, max_tokens=250, model='mistral-small-latest', api_key=None, api_url=\"https://api.mistral.ai/v1/chat/completions\"):\n    \"\"\"\n    Uses AI to generate responses based on prompts and optional data ranges.\n\n    Args:\n        prompt (str): The question, task, or analysis to perform\n        data (list, optional): 2D list containing data from Excel range to analyze\n        temperature (float, optional): Controls response creativity (0-2). Default is 0.5\n        max_tokens (int, optional): Maximum tokens for response generation\n        model (str, optional): ID of the model to use\n        api_key (str, optional): API key for authentication (e.g. for Mistral AI).  Get your own free Mistral API key at https://console.mistral.ai/\n        api_url (str, optional): OpenAI compatible URL. (e.g., https://api.mistral.ai/v1/chat/completions for Mistral AI).\n\n    Returns:\n        str: The AI-generated response\n    \"\"\"\n\n    # Login on the Functions tab for limited demo usage.  \n    if api_key is None or api_url is None:\n        if 'idToken' in globals():\n            api_key = globals()['idToken']\n            api_url = \"https://llm.boardflare.com\"\n        else:\n            return (\"Login on the Functions tab for limited demo usage, or sign up for a free Mistral AI account at https://console.mistral.ai/ and add your own api_key.\")\n\n    # Construct the message incorporating both prompt and data if provided\n    message = prompt\n    if data is not None:\n        data_str = json.dumps(data, indent=2)\n        message += f\"\\n\\nData to analyze:\\n{data_str}\"\n    \n    # Prepare the API request payload\n    payload = {\n        \"messages\": [{\"role\": \"user\", \"content\": message}],\n        \"temperature\": temperature,\n        \"model\": model,\n        \"max_tokens\": max_tokens\n    }\n    \n    headers = {\n        \"Authorization\": f\"Bearer {api_key}\",\n        \"Content-Type\": \"application/json\",\n        \"Accept\": \"application/json\"\n    }\n    \n    # Validate temperature\n    if not isinstance(temperature, (float, int)) or not (0 <= float(temperature) <= 2):\n        raise ValueError(\"temperature must be a float between 0 and 2 (inclusive)\")\n    # Validate max_tokens\n    if not isinstance(max_tokens, int) or not (5 <= max_tokens <= 5000):\n        raise ValueError(\"max_tokens must be an integer between 5 and 5000 (inclusive)\")\n    \n    # Make the API request\n    response = requests.post(api_url, headers=headers, json=payload)\n    if response.status_code == 429:\n        return \"You have hit the rate limit for the API. Please try again later.\"\n    response.raise_for_status()\n    # Extract and return the response content\n    response_data = response.json()\n    content = response_data[\"choices\"][0][\"message\"][\"content\"]\n\n    return content"
  },
  {
    "name": "test_cases.json",
    "content": "[\n    {\n        \"id\": \"test_hr_engagement_summary\",\n        \"description\": \"HR: Summarize employee engagement survey results.\",\n        \"arguments\": {\n            \"prompt\": \"Summarize the key findings from the employee engagement survey in 1 sentence:\",\n            \"data\": [\n                [\n                    \"Question\",\n                    \"Score\"\n                ],\n                [\n                    \"Team collaboration\",\n                    4.5\n                ],\n                [\n                    \"Workload\",\n                    3.2\n                ],\n                [\n                    \"Career advancement\",\n                    3.0\n                ],\n                [\n                    \"Management support\",\n                    4.0\n                ]\n            ]\n        },\n        \"expected_contains_any\": [\n            \"collaboration\",\n            \"workload\",\n            \"career\"\n        ],\n        \"expected_rows\": 2,\n        \"demo\": true\n    },\n    {\n        \"id\": \"test_sales_quarterly_analysis\",\n        \"description\": \"Sales: Analyze quarterly sales data and provide insights.\",\n        \"arguments\": {\n            \"prompt\": \"Provide a brief analysis of the quarterly sales performance in 1 sentence:\",\n            \"data\": [\n                [\n                    \"Region\",\n                    \"Q1\",\n                    \"Q2\",\n                    \"Q3\",\n                    \"Q4\"\n                ],\n                [\n                    \"North\",\n                    120,\n                    135,\n                    150,\n                    160\n                ],\n                [\n                    \"South\",\n                    100,\n                    110,\n                    120,\n                    130\n                ],\n                [\n                    \"Central\",\n                    90,\n                    95,\n                    100,\n                    105\n                ]\n            ]\n        },\n        \"expected_contains_any\": [\n            \"North\",\n            \"growth\",\n            \"sales\"\n        ],\n        \"expected_rows\": 2,\n        \"demo\": true\n    },\n    {\n        \"id\": \"test_operations_incident_summary\",\n        \"description\": \"Operations: Summarize an incident report.\",\n        \"arguments\": {\n            \"prompt\": \"Summarize the following incident report in 1 sentence:\",\n            \"data\": [\n                [\n                    \"On April 10th, a system outage affected order processing for 2 hours. The IT team resolved the issue by updating server configurations. No data loss occurred.\"\n                ]\n            ]\n        },\n        \"expected_contains_any\": [\n            \"outage\",\n            \"resolved\",\n            \"data loss\"\n        ],\n        \"expected_rows\": 2,\n        \"demo\": true\n    },\n    {\n        \"id\": \"test_parameters\",\n        \"description\": \"Test that all optional parameters work correctly\",\n        \"arguments\": {\n            \"prompt\": \"Write a very short test response\",\n            \"temperature\": 0.8,\n            \"max_tokens\": 50,\n            \"model\": \"mistral-small-latest\",\n            \"api_key\": \"test_key\",\n            \"api_url\": \"https://api.mistral.ai/v1/chat/completions\"\n        },\n        \"expected_rows\": 1,\n        \"demo\": false\n    },\n    {\n        \"id\": \"test_different_models_default\",\n        \"description\": \"Test that different models can be used (default)\",\n        \"arguments\": {\n            \"prompt\": \"Write a one-sentence test response\",\n            \"api_key\": \"test_key\",\n            \"api_url\": \"https://api.mistral.ai/v1/chat/completions\"\n        },\n        \"expected_rows\": 1,\n        \"demo\": false\n    },\n    {\n        \"id\": \"test_different_models_specified\",\n        \"description\": \"Test that different models can be used (specified)\",\n        \"arguments\": {\n            \"prompt\": \"Write a one-sentence test response\",\n            \"model\": \"mistral-small-latest\",\n            \"api_key\": \"test_key\",\n            \"api_url\": \"https://api.mistral.ai/v1/chat/completions\"\n        },\n        \"expected_rows\": 1,\n        \"demo\": false\n    },\n    {\n        \"id\": \"test_invalid_temperature_low\",\n        \"description\": \"Test temperature below valid range (should raise ValueError)\",\n        \"arguments\": {\n            \"prompt\": \"Test invalid temperature low\",\n            \"temperature\": -0.1,\n            \"api_key\": \"test_key\",\n            \"api_url\": \"https://api.mistral.ai/v1/chat/completions\"\n        },\n        \"expected_exception\": \"ValueError\",\n        \"demo\": false\n    },\n    {\n        \"id\": \"test_invalid_temperature_high\",\n        \"description\": \"Test temperature above valid range (should raise ValueError)\",\n        \"arguments\": {\n            \"prompt\": \"Test invalid temperature high\",\n            \"temperature\": 2.1,\n            \"api_key\": \"test_key\",\n            \"api_url\": \"https://api.mistral.ai/v1/chat/completions\"\n        },\n        \"expected_exception\": \"ValueError\",\n        \"demo\": false\n    },\n    {\n        \"id\": \"test_invalid_max_tokens_low\",\n        \"description\": \"Test max_tokens below valid range (should raise ValueError)\",\n        \"arguments\": {\n            \"prompt\": \"Test invalid max_tokens low\",\n            \"max_tokens\": 0,\n            \"api_key\": \"test_key\",\n            \"api_url\": \"https://api.mistral.ai/v1/chat/completions\"\n        },\n        \"expected_exception\": \"ValueError\",\n        \"demo\": false\n    },\n    {\n        \"id\": \"test_invalid_max_tokens_high\",\n        \"description\": \"Test max_tokens above valid range (should raise ValueError)\",\n        \"arguments\": {\n            \"prompt\": \"Test invalid max_tokens high\",\n            \"max_tokens\": 6000,\n            \"api_key\": \"test_key\",\n            \"api_url\": \"https://api.mistral.ai/v1/chat/completions\"\n        },\n        \"expected_exception\": \"ValueError\",\n        \"demo\": false\n    }\n]"
  }
] } />
